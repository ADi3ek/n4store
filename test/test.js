// Generated by CoffeeScript 1.4.0
(function() {
  var assert, async, debugn4store, exec, path, request, sugar;

  exec = require("child_process").exec;

  assert = require('assert');

  async = require('async');

  request = require('request');

  sugar = require('sugar');

  path = require('path');

  debugn4store = false;

  describe('N4Store', function() {
    var dbName, destroyDb, endPoint, getNTriples, graph, kill4sProcesses, launchDb, n4store, port, resetDb, triple, turtleData, turtleFile, turtleFilename, turtleFiles;
    dbName = "n4storeTestDb";
    port = 10000;
    endPoint = "http://0.0.0.0:" + port;
    n4store = null;
    launchDb = function(callback) {
      return async.series([
        function(callback) {
          return exec("4s-backend-setup " + dbName, function(err) {
            if (err) {
              console.log("4s-backend-setup ", err);
            }
            return callback(null);
          });
        }, function(callback) {
          return exec("4s-backend " + dbName, function(err) {
            if (err) {
              console.log("4s-backend", err);
            }
            return callback(null);
          });
        }, function(callback) {
          return exec("4s-httpd -p " + port + " " + dbName, function(err) {
            if (err) {
              console.log("4s-httpd", err);
            }
            return callback(null);
          });
        }
      ], function() {
        return callback(null);
      });
    };
    kill4sProcesses = function(callback) {
      return async.series([
        function(callback) {
          return exec("pkill -f '^4s-backend " + dbName + "$'", function(err, body) {
            return callback(null);
          });
        }, function(callback) {
          return exec("killall 4s-httpd", function(err, body) {
            return callback(null);
          });
        }
      ], function() {
        return callback();
      });
    };
    destroyDb = function(callback) {
      return exec("4s-backend-destroy " + dbName, function(err) {
        return callback();
      });
    };
    resetDb = function(callback) {
      return async.series([
        function(callback) {
          return kill4sProcesses(callback);
        }, function(callback) {
          return launchDb(callback);
        }
      ], function() {
        n4store = require('../').createClient(endPoint, null, debugn4store);
        return callback();
      });
    };
    graph = 'urn:graph';
    triple = {
      subject: "urn:resource",
      predicate: "urn:predicate",
      object: "literal"
    };
    turtleData = "<" + triple.subject + "> <" + triple.predicate + "> <" + triple.object + "> .\n<" + triple.subject + "> <" + triple.predicate + "> <" + triple.object + "> .\n<" + triple.subject + "> <" + triple.predicate + "> \"literal 2\" .";
    turtleFiles = ["" + __dirname + "/fixtures/turtleData2.ttl", "" + __dirname + "/fixtures/turtleData3.ttl"];
    turtleFile = "" + __dirname + "/fixtures/turtleData.ttl";
    turtleFilename = path.basename(turtleFile);
    after(function(done) {
      return destroyDb(done);
    });
    getNTriples = function(n, callback) {
      return n4store.get("SELECT ?s ?p ?o ?g\nWHERE {\n  GRAPH ?g {\n  ?s ?p ?o\n  }\n}", function(err, sparql) {
        assert.equal(n, sparql.results.bindings.length);
        return callback(sparql.results.bindings);
      });
    };
    describe("Connection", function() {
      return it("server must be starts on port " + port + " ", function(done) {
        return resetDb(function() {
          return request({
            method: "GET",
            url: "" + endPoint + "/status"
          }, function(err, res, body) {
            if (err) {
              done(err);
            }
            assert.equal(true, body.indexOf("Total # triples imported: 0") > -1);
            return done();
          });
        });
      });
    });
    describe("SPARQL", function() {
      it("sparql get request should return 0 results", function(done) {
        return getNTriples(0, function(triples) {
          return done();
        });
      });
      it("should insert one triple and get 1 result", function(done) {
        return n4store.post("INSERT {\n  GRAPH <" + graph + "> {\n    <" + triple.subject + "> <" + triple.predicate + "> \"" + triple.object + "\"\n  }\n}", function(err, body) {
          assert.equal(err, null);
          return done(err);
        });
      });
      it("should get the same graph, subject, predicate and object in sparql get", function(done) {
        return getNTriples(1, function(triples) {
          assert.equal(triple.subject, triples[0].s.value);
          assert.equal(triple.predicate, triples[0].p.value);
          assert.equal(triple.object, triples[0].o.value);
          assert.equal(graph, triples[0].g.value);
          return done();
        });
      });
      it("should delete the triple based on subject", function(done) {
        return n4store.post("DELETE {\n  <" + triple.subject + "> ?p ?o \n} WHERE {\n  <" + triple.subject + "> ?p ?o \n}", function(err, body) {
          assert.equal(null, err);
          return done(err);
        });
      });
      return it("store should be empty", function(done) {
        return getNTriples(0, function(triples) {
          return done();
        });
      });
    });
    describe("POST data (append data to a graph)", function() {
      describe("use postData", function() {
        it("should post turtle data (3 triples but 2 identical)", function(done) {
          return n4store.postData(turtleData, graph, function(err, body) {
            assert.equal(null, err);
            assert.equal(true, body.indexOf("200") > -1);
            return done();
          }, 'turtle');
        });
        return it("should get 2 result (4store compiled with --enable-dedup-insert) and 1 must have object as 'literal 2'", function(done) {
          return getNTriples(2, function(triples) {
            assert.equal(true, triples.any(function(triple) {
              return triple.o.value === "literal 2";
            }));
            return done();
          });
        });
      });
      describe("use postFile", function() {
        it("should append turtle data from file " + turtleFile, function(done) {
          return n4store.postFile(turtleFile, null, function(err) {
            assert.equal(null, err);
            return done();
          });
        });
        it("should contains 2 graphs", function(done) {
          return n4store.getGraphs(function(err, uris) {
            assert.equal(2, uris.length);
            return done();
          });
        });
        return it("should contain one graph with " + turtleFilename, function(done) {
          return n4store.getGraphs(function(err, uris) {
            assert.equal(true, uris.any(function(uri) {
              return uri === ("urn:" + turtleFilename);
            }));
            return done();
          });
        });
      });
      return describe("use postFiles", function() {
        it("should append two more files ", function(done) {
          return n4store.postFiles(turtleFiles, graph, function(err) {
            assert.equal(null, err);
            return done(err);
          }, 'turtle');
        });
        it("should have 2 graph only", function(done) {
          return n4store.getGraphs(function(err, uris) {
            assert.equal(2, uris.length);
            return done();
          });
        });
        return it("graph " + graph + " must contains 5 triples", function(done) {
          return getNTriples(7, function(triples) {
            return done();
          });
        });
      });
    });
    describe("PUT data (replace data in a graph)", function() {
      describe("use put", function() {
        it("should replace data in graph " + graph, function(done) {
          return n4store.put("<" + triple.subject + "> <" + triple.predicate + "> <" + triple.object + "> .", graph, function(err, body) {
            assert.equal(null, err);
            assert.equal(true, body.indexOf('201') > -1);
            return done();
          });
        });
        it("store should contains only 2 triples", function(done) {
          return getNTriples(2, function(triples) {
            return done();
          });
        });
        it("should replace data in urn:" + turtleFilename + " graph", function(done) {
          return n4store.put("<" + triple.subject + "> <" + triple.predicate + "> <" + triple.object + "> .", "urn:" + turtleFilename, function(err, body) {
            assert.equal(null, err);
            assert.equal(true, body.indexOf('201') > -1);
            return done();
          });
        });
        it("store should contains only 2 triples", function(done) {
          return getNTriples(2, function(triples) {
            return done();
          });
        });
        return it("should have two identical triples in two diffrent graph", function(done) {
          return getNTriples(2, function(triples) {
            var triple1, triple2;
            triple1 = triples[0];
            triple2 = triples[1];
            assert.equal(true, triple1.s.value === triple2.s.value);
            assert.equal(true, triple1.p.value === triple2.p.value);
            assert.equal(true, triple1.o.value === triple2.o.value);
            return done();
          });
        });
      });
      describe("use putFile", function() {
        it("should put file " + turtleFilename + " in graph " + graph, function(done) {
          return n4store.putFile(turtleFile, graph, function(err, body) {
            assert.equal(null, err);
            assert.equal(true, body.indexOf('201') > -1);
            return done();
          });
        });
        return it("should contain on one triple in graph " + graph, function(done) {
          return n4store.get("SELECT ?s ?p ?o \nWHERE {\n  GRAPH <" + graph + "> {\n    ?s ?p ?o\n  }\n}", function(err, sparql) {
            assert.equal(true, sparql.results.bindings.length === 1);
            triple = sparql.results.bindings.first();
            assert.equal("urn:resource2", triple.s.value);
            assert.equal("urn:predicate", triple.p.value);
            assert.equal("literal", triple.o.value);
            return done();
          });
        });
      });
      return describe("use putFiles", function() {
        it("should put files " + turtleFiles + " in their own graph names", function(done) {
          return n4store.putFiles(turtleFiles, null, function(err, body) {
            return done();
          });
        });
        return it("should have 4 graph names ", function(done) {
          return n4store.getGraphs(function(err, uris) {
            assert.equal(4, uris.length);
            return done();
          });
        });
      });
    });
    describe("CONSTRUCT", function() {
      return it("should return a construct turtle", function(done) {
        return n4store.construct("CONSTRUCT {\n  ?s ?p ?o \n}\nWHERE {\n  ?s ?p ?o\n}", function(err, turtle) {
          assert.equal(null, err);
          assert.equal(true, turtle.length > 0);
          return done();
        });
      });
    });
    return describe("DELETE graph", function() {
      return it("should delete graph " + graph, function(done) {
        return n4store["delete"](graph, function(err, body) {
          assert.equal(null, err);
          assert.equal(true, body.indexOf("200") > -1);
          return done();
        });
      });
    });
  });

}).call(this);
